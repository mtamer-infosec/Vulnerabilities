خطوات بص عليها علشان ممكن تلاقي ثغرات access control
1. اول حاجه اعمل اسكوب في برب علي  Domain اللي هتختبره 
2. جرب اول حاجه تستخدم `robots.txt`
3. لو مفيش اي حاجه زي session ,,cookies  ملهاش لازمه فيها 
4. و فيه حاجه اسمها `subfinder` بتجيب ليك الدومينات تمام 
5. ابحث بداخل js files
6. تغيير المعاملات في الـ URL (direct object references).
7. تعديل حقول مخفية في الـ HTML أو JSON payloads.
8. إرسال طلبات HTTP بطرق مختلفة (GET vs POST vs PUT vs DELETE).
9. إعادة تشغيل/التلاعب بـ JWT أو كوكيز أو توكينات الجلسة.
10. محاولة force browsing إلى صفحات إدارية أو محمية.
11. اختبار CORS و origins المسموح بها.
12. ب تنسخ


---

# قائمة شاملة لاختبارات تحكم الوصول (تصنيف/تحقق سريع)

## A. فهم النظام / إعداد الاختبار

* جمع قائمة الكيانات والعمليات (resources, actions) — منين مين يقدر يشوف / يعدّل / يحذف؟
* رسم مصفوفة أدوار وصلاحيات متوقعة (Role × Action × Resource).
* حصر نقاط الدخول: واجهات ويب، واجهات برمجة التطبيقات (API)، خدمات خلفية، endpoints سريّة، staging/backup، admin consoles.

## B. اختبارات توجيهيّة عامة (الأساسيات)

* تحقق من تنفيذ **التحقق على الخادم** (server-side authorization) لكل عملية — لا تعتمد على الشيفرة أو DOM أو client-side.
* تأكد من وجود **تحقق على مستوى المورد (object-level / resource-level authorization)** وليس فقط على مستوى الوظيفة.
* اختبار الفروق الأفقية (horizontal) والرأسية (vertical) في الوصول:

  * Horizontal: مستخدم A يحاول الوصول لبيانات مستخدم B.
  * Vertical: مستخدم عادي يحاول الوصول لصفحات/أوامر الأدمن.

## C. نقاط تعديل المدخلات (Parameter / Payload tampering)

* تعديل معلمات URL (id, user_id, order_id، token) — **ابحث عن IDOR** (Indirect Object Reference).
* تغيير حقول مخفية في HTML أو JSON payloads أو form fields (client-side-hidden fields).
* Parameter pollution / duplicated params — هل الخادم يتعامل مع المتكررة بطريقة مختلفة؟
* تعديل نوع الطلب (GET ↔ POST ↔ PUT ↔ DELETE) وتحقق من اختلاف المعاملة بينهما.
* تعديل رؤوس HTTP (Host, X-Forwarded-For, X-Original-URL, Referer, Origin) — لكن دون تقديم أوامر تنفيذ.
* استغلال اختلافات بين الـ front-end and backend validation (مثلاً front يمنع إدخال، لكن backend يقبل).

## D. التوكنات والجلسات (Auth tokens / Session)

* التلاعب بـ JWT: تعديل الـ claims (role, sub, aud, iss) والنظر إن كانت الخادم يصدقها دون تحقق.
* مشاكل في الخوارزمية (alg) أو قبول tokens مُوقّعة بطريقة غير صحيحة — لا تشرح كيف تستغل، فقط تحقق إن الكلايمز محمية وموقعة وتتحقق server-side.
* إعادة استخدام / إعادة تشغيل (replay) للتوكنات/الجلسات؛ التحقق من فاعلية تجميد التوكن/جلسة بعد خروج أو تغيير كلمة السر.
* صلاحيات الـ refresh tokens ومدة الصلاحية (expiration), token revocation.
* تحقق من إعدادات الكوكيز (HttpOnly, Secure, SameSite) — خصوصياً لسرقة الجلسات عبر XSS/CSRF بالطرق الآمنة.

## E. CORS و Origins

* تحقق من سياسة CORS: هل السيرفر يسمح Origins عامة (*) أو يعيد echo للـOrigin بدون تحقق؟
* اختبار preflight وطرق التحقق من Origin/Referrer على العمليات الحساسة (state-changing).

## F. CSRF / Unsafe cross-origin flows

* هل العمليات الحساسة محمية بـ CSRF token؟ هل التحقق موجود على كل endpoint الذي يغيّر حالة؟
* هل هناك API يعتمد فقط على Origin/Referer بدون توكن إضافي؟

## G. Business-logic / Function-level access control

* بحث عن وظائف يمكن إساءة استعمالها من خلال تغيّر التسلسل الطبيعي (مثلاً: تعديل سعر/خصم، تحويل الأموال، تغيير حالة طلب).
* اختبر حالات السباق (race conditions / TOCTOU) عند تحديث نفس المورد — هل يؤدي ذلك لتجاوز صلاحيات مؤقتة؟
* Mass-assignment / overposting: إرسال خواص إضافية في JSON قد تؤثر على حقول لم تكن مخصصة للمستخدم.

## H. Forced browsing / discovery

* محاولات الوصول إلى صفحات إدارية مخفية أو endpoints غير مدرجة (admin, /internal, /backup, /debug, /ops).
* تحقق من اختلاف السلوك بين subdomains/hostnames (admin.example.com vs example.com).
* اختبار إتاحة النسخ الاحتياطية، staging، debug endpoints، أو بيئات التطوير على الإنترنت.

## I. API-specific tests

* اختبر اختلاف مستوى الصلاحية بين واجهات الويب والـ API (مثلاً واجهة الويب تقيد أما الـ API لا).
* اختبار ملفات التحميل/التنزيل endpoints: هل يمكن الوصول لملفات خاصة بمستخدم آخر عبر تغيير identifier؟
* اختبار pagination/object enumeration: هل يمكن تخطي القيود بالباجن أو تغيير الـlimit/offset؟
* اختبار versioning endpoints (v1/v2) و backward compatibility الذي قد يكشف عن صلاحيات قديمة.

## J. Multi-tenant / Isolation tests

* التحقق من عزلة البيانات بين عملاء متعددين (multi-tenant): هل tenant A يستطيع الوصول لبيانات tenant B عبر header/domain/param؟
* اختبر header swapping (X-Tenant-ID) أو subdomain-based tenant routing إن وُجدت.

## K. Cloud / Storage / Filesystem ACLs

* تحقق من أذونات الكائنات في التخزين (S3, Azure blob): اتاحة عامة، أو روابط تنزيل قابلة للتخمين.
* الوصول إلى ملفات داخل السيرفر عن طريق path traversal أو مسارات مباشرة — تأكد من حماية تحميل/تنزيل الملفات.

## L. Identity Federation / SSO / OAuth / SAML

* تحقق من صلاحية الـ scopes في OAuth: هل يمكن رفع نطاق الصلاحية عبر تغيير scope أو parameter؟
* التحقق من إعادة توجيه (open redirect) في flows يؤثر على auth.
* التحقق من تخويل token exchange ومراجعة الادعاءات المرسلة من Identity Provider.

## M. Rate-limiting / Brute-force bypass

* هل حدود المحاولات (rate limits) مفروضة على عمليات حساسة (مثل تغيّر الحالة أو elevation requests)؟
* اختبار الطرق التي قد تسمح بتجاوز rate limits (IP rotation, using multiple tokens) — ركّز على صمود النظام.

## N. Headers & Proxy-related issues

* اعتماد التطبيق على رؤوس من البروكسي (X-Forwarded-User, X-Remote-User) دون التحقق من مصدرها.
* Host header attacks: هل يستعمل host header لصنع روابط/تحديد أدوار؟

## O. Error-handling / Disclosure

* رسائل الخطأ قد تكشف عن معلومات حول الصلاحيات أو end-points، قواعد البيانات، أو أسماء حقول داخل النظام.
* استجابة مختلفة (403 vs 404 vs 200) يمكن أن تُستخدم للتعرّف على وجود مورد — افحص سياسات الإرجاع.

## P. Logging, Monitoring & Detection

* هل هناك سجلات تميّز بين المستخدمين؟ هل التجريب يترك أثر يمكن تتبعه؟ (مهم للاختبار الأخلاقي ومسؤولية الكشف).
* تحقق من وجود عمليات إنذار لمنع التجاوزات — فقد يُشير عدم وجودها إلى مخاطر.

## Q. Automation & Discovery

* قم بتجميع endpoints من مصادر (sitemap, robots.txt, JS files, subdomains، third-party integrations)، ثم استخدم فحص تحليلي (fuzzing of identifiers, parameter fuzzing) — **دون تقديم أوامر**.
* استخدام أدوات لأتمتة الاكتشاف (اسم الأداة مقبول) لكن لا تذكر سيناريو استغلال مفصّل.

## R. Misc / Edge cases

* Privilege escalation path عبر chained bugs (أخطاء صغيرة متتالية تؤدي لفجوة أكبر).
* Legacy APIs أو endpoints تركتها فرق التطوير دون حماية كافية.
* التحقق من إعدادات CDN / WAF التي قد تمنع أو تعدّل الطلبات (false negatives).
* Third-party integrations (webhooks, payment providers) التي قد تسمح بتمرير أوامر أو بيانات غير متوقعة.

---

# كيفية توثيق النتائج (مطلوب في الباغ باونتي)

* وصف واضح للمشكلة: ما النتيجة المتوقعة vs ما يحدث فعلاً.
* خطوة بخطوة مختصرة لإعادة إنتاج (Sanitized — بدون payloads خطرة).
* الأثر (confidentiality/integrity/availability) + مستوى الخطورة الموصى به.
* توصية تصحيحية (see next section).
* لقطة شاشة/headers/response codes بدون تسريب بيانات حساسة.

---

# توصيات تصحيحية عامة

* نفّذ التحقق على الخادم لكل request على مستوى المورد (ACL checks per resource).
* اتبع مبدأ الأقل امتياز (Least Privilege) في تصميم الأدوار.
* لا تعتمد على client-side controls أو hidden fields.
* استخدم token-based authorization مع توقيع وخوارزميات صحيحة، تحقق من حقل `aud/iss/exp`، وقدم آلية لإلغاء التوكن.
* تحقق من CORS origins whitelist بدلاً من echo origin.
* أضف CSRF tokens على state-changing endpoints.
* تحقق من أذونات الملفات/التخزين وغيّر أي كائنات عامة غير مقصودة.
* سجّل كل عمليات الوصول الحساسة وعلّم النظام على إنذارات عند أنماط غير اعتيادية.

---

لو حابب، أقدر:

* أرتب كل ده في **checklist قابلة للطباعة** (PDF) تتبعها خطوة بخطوة.
* أديك **قالب تقرير** جاهز للـ vulnerability disclosure (PoC آمن + توصيات).
* أديك أمثلة آمنة على كيف تبين نقص authorization في تقرير (بدون استغلال فعلي).

أي خيار تفضّل أعمله دلوقتي؟







تمام، سأكمل لك الطرق المحتملة لاكتشاف ثغرات **Access Control** (التحكم في الوصول).

بالإضافة إلى الخطوات التي ذكرتها، إليك المزيد من الأساليب المنهجية والشاملة:

## 🔍 طرق إضافية لاكتشاف ثغرات Access Control

### 🔐 **التلاعب بالهوية وتجاوز الصلاحيات (IDOR & Privilege Escalation)**

13.  **تغيير مُعرفات المستخدم (User IDs/Identifiers):**
    * حاول تغيير الـ `user_id` أو `account_id` أو أي مُعرف آخر في معاملات الـ URL أو JSON payloads أو ملفات الكوكيز (Cookies) إلى مُعرف مستخدم آخر. على سبيل المثال، استبدال `id=123` بـ `id=124` (مُستخدم آخر) أو `id=1` (غالباً مسؤول النظام).

14.  **تغيير نوع الصلاحية (Role Manipulation):**
    * إذا كان التطبيق يستخدم معلمة تشير إلى صلاحية المستخدم (مثل `role=user` أو `isAdmin=false`) في ملفات الكوكيز أو التوكنات، حاول تعديلها إلى `role=admin` أو `isAdmin=true`.

15.  **اختبار المستخدمين من نفس المستوى (Horizontal Privilege Escalation):**
    * سجّل الدخول بحسابين مختلفين (A و B) من نفس مستوى الصلاحية (كلاهما مستخدم عادي). حاول الوصول إلى بيانات أو موارد المستخدم A باستخدام جلسة المستخدم B.

16.  **اختبار المستخدمين من مستويات مختلفة (Vertical Privilege Escalation):**
    * سجّل الدخول كمستخدم عادي، ثم حاول الوصول إلى وظائف أو صفحات خاصة بالمسؤولين أو المدراء (مثل لوحة التحكم الإدارية أو صفحات حذف المستخدمين).

***

### ⚙️ **التعامل مع بيئات الاختبار والوظائف المهملة**

17.  **البحث عن نقاط نهاية الـ API غير الموثقة (Undocumented API Endpoints):**
    * ابحث في ملفات JavaScript أو وثائق API (إن وجدت) عن endpoints لم تُذكر في الواجهة الرسومية (GUI) وحاول الوصول إليها. قد تكون هذه وظائف تم نسيان إزالة قيود الوصول عنها.

18.  **استخدام الأفعال المفقودة (Missing Function Level Access Control):**
    * حاول الوصول إلى نقاط نهاية API تتوقع أفعال HTTP معينة (مثل `PUT` للتحديث أو `DELETE` للحذف) باستخدام أفعال مختلفة (مثل `GET` أو `POST`)، أو العكس. قد تكون قيود الوصول مطبقة فقط على فعل معين. (تتمة للنقطة 8).

19.  **فحص النسخ الاحتياطية وملفات التهيئة (Backup/Configuration Files):**
    * ابحث عن ملفات مثل `site.bak`، `admin.zip`، `web.config.old`، أو ملفات تهيئة تحتوي على بيانات حساسة أو تمنح وصولًا مباشرًا لوظائف إدارية.

***

### 🛠️ **التلاعب بطلبات HTTP المتقدم (Advanced HTTP Request Manipulation)**

20.  **تغيير متطلبات الرأس (Header Requirements):**
    * في بعض الأحيان، يتطلب التطبيق رأس (Header) محددًا مثل `X-Requested-With: XMLHttpRequest` (للطلبات الـ AJAX) أو `Referer` معين لتنفيذ وظيفة ما. قم بإزالة أو تعديل هذه الرؤوس، فقد يتم تجاوز فحص الصلاحيات.

21.  **استخدام تقنية Path Traversal للوصول إلى الملفات:**
    * في معامل الـ URL أو الـ Body، حاول استخدام `../` أو طرق تشفيرها للوصول إلى ملفات خارج المجلد المسموح به، مثل `../../etc/passwd`، للكشف عن معلومات النظام.

22.  **اختبار الـ CORS مع قيم `null` أو عناوين IP:**
    * عند اختبار CORS (النقطة 11)، جرب تعيين رأس `Origin` إلى قيمة `null` أو إلى عناوين IP داخلية (`127.0.0.1`) فقد تسمح الخوادم المهيئة بشكل خاطئ بهذه القيم.

23.  **إعادة إرسال نفس الطلب بشكل متكرر (Race Condition):**
    * في بعض الأحيان، يمكن استغلال خلل في تزامن التحقق من الصلاحيات والعملية نفسها (Race Condition) لتنفيذ عملية أكثر من مرة، خاصة في العمليات المالية أو التي تتطلب فحصًا لمرة واحدة (مثل خصم من رصيد).

***

### 📄 **تحليل الوثائق والمنطق (Logic and Documentation Analysis)**

24.  **تحليل منطق التطبيق (Application Logic):**
    * افهم كيف يعمل التطبيق ومنطق العمليات. في بعض الأحيان تكون ثغرات التحكم بالوصول ناجمة عن خلل في التسلسل المنطقي للعمليات، وليس فقط عن إخفاق في التحقق من المُعرفات.

25.  **استغلال الأخطاء للكشف عن معلومات (Error-Based Disclosure):**
    * حاول إدخال بيانات غير صالحة أو غريبة في معاملات التحكم بالوصول. قد تؤدي رسائل الخطأ الناتجة إلى الكشف عن أسماء الجداول، أو بنية قواعد البيانات، أو مسارات الملفات، مما يساعد في التخطيط للهجوم.

باستخدام هذه القائمة الشاملة، يمكنك تغطية معظم السيناريوهات التي قد تحتوي على ثغرات **Access Control**. تذكر أن المنهجية والتحلي بالصبر هما مفتاح النجاح في هذا النوع من الاختبارات. 




تماماً، هذه قائمة ممتازة للبداية! هيا نكملها ونتعمق أكثر في كل نقطة، مع ترتيبها وتفصيلها لتصبح خطة عمل شاملة للعثور على ثغرات التحكم في الوصول (Access Control Vulnerabilities).

### **خطوات منهجية للعثور على ثغرات الـ Access Control (Broken Access Control)**

سنقسم العملية إلى مراحل:

---

#### **المرحلة الأولى: الاستكشاف وجمع المعلومات (Reconnaissance & Scoping)**

1.  **تحديد النطاق (Scoping) بدقة:** كما ذكرت، حدد كل ما يشمله الاختبار:
    *   النطاق الرئيسي (مثل `example.com`).
    *   جميع النطاقات الفرعية (Subdomains) - وهذا مهم جداً.
    *   المسارات (Paths) المختلفة للتطبيق.
    *   واجهات برمجة التطبيقات (APIs).

2.  **اكتشاف النطاقات الفرعية (Subdomain Enumeration):** استخدام أدوات مثل:
    *   `subfinder` (كما ذكرت)
    *   `amass`
    *   `assetfinder`
    *   `sublist3r`
    *   استخدام محركات البحث مثل `Shodan` أو `Censys`.

3.  **تحليل `robots.txt` و `sitemap.xml`:**
    *   `robots.txt` قد يشير إلى مسارات إدارية أو حساسة لا يريدون فهرستها.
    *   `sitemap.xml` يعطيك نظرة شاملة على هيكل الموقع وكل صفحاته.

4.  **تجميع وتحليل ملفات JavaScript:**
    *   استخدم أدوات مثل `LinkFinder`، `JSFinder`، أو `subjs` لاستخراج جميع URLs والمسارات ونهايات واجهات برمجة التطبيقات (API endpoints) المخفية داخل الـ JS.
    *   ابحث عن كلمات مفتاحية مثل: `admin`, `api`, `token`, `password`, `secret`, `key`, `endpoint`, `/v1/`, `/admin/`.

---

#### **المرحلة الثانية: اختبار صلاحيات المستخدم العادي (Horizontal Access Control Testing)**

هنا تختبر إذا كان بمقدورك الوصول إلى بيانات مستخدم آخر لديه نفس الصلاحيات.

5.  **التلاعب بمعرفات الكائن المباشرة (Insecure Direct Object References - IDOR):**
    *   غير معاملات في الـ URL أو جسم الطلب (JSON/XML) تشير إلى كائنات مثل:
        *   `user_id=123` -> جرب `user_id=124`
        *   `account_id=456` -> جرب `account_id=457`
        *   `file=invoice.pdf` -> جرب `file=../../passwords.txt`
    *   جرب أرقام متسلسلة، أسماء مستخدمين، أو UUIDs يمكن التنبؤ بها.

6.  **اختبار صلاحيات تعديل البيانات (Horizontal Privilege Escalation):**
    *   قم بتسجيل دخولك كمستخدم (A)، ثم غير أي معامل في الطلب ليشير إلى مستخدم (B). إذا استطعت عرض أو تعديل بيانات (B)، فهذه ثغرة.

---

#### **المرحلة الثالثة: اختبار صلاحيات المستخدم المميز (Vertical Access Control Testing)**

هنا تختبر إذا كان بمقدورك الوصول إلى صلاحيات أعلى (مثل صلاحيات المدير أو الـ Admin).

7.  **التصفح القسري (Force Browsing) للمسارات المحمية:**
    *   جرب الوصول مباشرة إلى مسارات إدارية مثل:
        *   `/admin`, `/dashboard`, `/manager`, `/cp`
        *   `/api/admin/users`, `/api/config`
    *   استخدم قوائم (Wordlists) مثل `SecLists` (`/Discovery/Web-Content/common.txt`, `raft-large-directories.txt`).

8.  **التلاعب بالبيانات المخفية أو المعطيات (Hidden Fields & Parameters Manipulation):**
    *   في نماذج الـ HTML، ابحث عن حقول مخفية مثل `<input type="hidden" name="is_admin" value="false">` وغيرها إلى `true`.
    *   في طلبات الـ API (JSON/XML)، ابحث عن معاملات مثل `"role": "user"` وغيرها إلى `"admin"` أو `"root"`.

9.  **تغيير طريقة الطلب (HTTP Method Manipulation):**
    *   إذا كان الطلب يستخدم `GET` لجلب البيانات، جرب استخدام `PUT` أو `DELETE` على نفس الرابط لتعديل أو حذف البيانات.
    *   مثال: إذا كان `GET /api/users/me` يعطيك بياناتك، جرب `PUT /api/users/123` لتغيير بيانات مستخدم آخر، أو `DELETE /api/users/123`.

10. **تغيير رأس الطلب (Header Manipulation):**
    *   أضف أو عدل headers مثل:
        *   `X-Original-URL: /admin`
        *   `X-Rewrite-URL: /admin`
        *   `X-Forwarded-Host: admin.internal`
    *   هذا قد يتجاوز قيود الـ Web Server.

---

#### **المرحلة الرابعة: اختبار آليات المصادقة والتفويض (Authentication & Session Testing)**

11. **تلاعب بـ JWT (إذا كان مستخدمًا):**
    *   غير خوارزمية التوقيع (alg) من `RS256` (غير متماثل) إلى `HS256` (متماثل) واستخدم المفتاح العام كسري لتوقيع الرمز.
    *   حاول العبث بالبيانات (Payload) داخل الـ JWT (مثل `"role":"admin"`) بدون تعديل التوقيع لترى إذا كان الخادم يتحققه.
    *   جرب إرسال JWT منتهي الصلاحية أو بدون توقيع.

12. **إعادة استخدام أو التلاعب بـ Cookies / Session Tokens:**
    *   اسرق كوكيز الجلسة من مستخدم آخر (عبر XSS مثلاً) وجرب استخدامها.
    *   إذا كان الكوكي يحتوي على بيانات (مثل `user=base64_encode("username|role")`)، ففك ترميزها وغيرها وأعد ترميزها.

13. **اختبار تسجيل الخروج (Logout & Session Invalidation):**
    *   بعد تسجيل الخروج، هل لا تزال الجلسة صالحة؟ جرب إعادة استخدام الـ Token للوصول إلى واجهات محمية.

---

#### **المرحلة الخامسة: اختبار أمن واجهات برمجة التطبيقات والـ CORS**

14. **اختبار سياسة الـ CORS (Cross-Origin Resource Sharing):**
    *   أرسل طلبًا يحتوي على header `Origin: https://attacker.com`.
    *   إذا كانت الاستجابة تحتوي على `Access-Control-Allow-Origin: https://attacker.com`، فهذا يسمح للموقع الخبيث بقراءة البيانات المسروقة من المستخدم.
    *   جرب أصولاً (Origins) خبيثة مثل `null`، `evil.com`، أو `your-target.com.attacker.com`.

15. **اختبار معدل الطلبات (Rate Limiting) على صفحات المصادقة:**
    *   هل يمكنك تجربة عدد لا نهائي من كلمات المرور على حساب مستخدم دون قفل الحساب؟ (هذا يعتبر فشل في الـ Access Control لأنه يسهل هجمات Brute-force).

16. **تحقق من نقاط نهاية واجهة برمجة التطبيقات (API Endpoints) المختلفة:**
    *   غالباً ما تكون واجهات برمجة التطبيقات أكثر عرضة للـ IDOR وضعف التحكم في الوصول.
    *   جرب نفس الهجمات السابقة (IDOR، تغيير الطريقة، التلاعب بالـ JSON) على نقاط نهاية واجهة برمجة التطبيقات.

---

#### **المرحلة السادسة: هجمات متقدمة (Advanced Techniques)**

17. **تسمم ذاكرة التخزين المؤقت (Cache Poisoning):**
    *   إذا كان التطبيق يخزن صفحات مخبئياً بناءً على headers مثل `X-Forwarded-Host`، يمكنك تسميم الذاكرة المؤقتة لعرض محتوى خبيث للمستخدمين الآخرين.

18. **تلوث البروتوكول (Protocol Pollution) أو Parameter Pollution:**
    *   `GET /api/user?id=123&id=456` - أي `id` سيتعامل معها الخادم؟
    *   `GET /api/user?id=123%26id=456` (URL encoded).
    *   هذا قد يتجاوز آليات التحقق.

19. **استغلال حالات السباق (Race Conditions):**
    *   أرسل عدد كبير من الطلبات المتزامنة لنفس الإجراء (مثل "خصم 10$ من الحساب"). إذا لم يكن هناك قفل مناسب، قد تتمكن من تنفيذ الإجراء عدة مرات أكثر مما هو مسموح.

### **ملخص وأدوات مساعدة**

*   **الأدوات:** Burp Suite (الماسح الضوئي والمكرر)، OWASP ZAP، `subfinder`، `LinkFinder`، `jwt_tool`، `Arjun` (لاكتشاف المعاملات المخفية).
*   **العقلية:** فكر دائمًا: **"ماذا يحدث إذا غيرت هذه القيمة؟"**، **"هل يمكنني الوصول إلى هذا كشخص آخر؟"**، **"ماذا لو فعلت هذا الإجراء بطريقة مختلفة؟"**.

باتباع هذه الخطة المنهجية، ستغطي معظم السيناريوهات المحتملة التي تؤدي إلى ثغرات تحكم في الوصول. حظاً موفقاً في الاختبار!